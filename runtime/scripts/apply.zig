// Do not edit this file, it was generated!

const std = @import("std");
const debug = std.debug;
const object = @import("object.zig");
const Closure = object.Closure;
const Object = object.Object;
const Box = object.Box;

pub const FnN = fn([*]Box) Box;

{% for n in range (1, amount + 1) %}
pub const Fn{{n}} = fn(
    *Closure,
    {% for i in range(n) %} Box, {% endfor %}
) Box;

pub fn call{{n}}(
    f: *Closure,
    {% for i in range(n) %} arg{{i}}: Box, {% endfor %}
) Box {
    return @as(*Fn{{n}}, @ptrCast(f.code))(
        f,
        {% for i in range(n) %} arg{{i}}, {% endfor %}
    );
}

pub fn apply_closure_{{n}}(
    f: *Closure,
    {% for i in range(n) %} arg{{i}}: Box, {% endfor %}
) Box {
    const arity = f.arity();

    // just right!
    if ({{n}} == arity) {
        return call{{n}}(
            @ptrCast(f),
            {% for i in range(n) %} arg{{i}}, {% endfor %}
        );
    }

    // too many args
    {% if n > 1 %}
    if ({{n}} > arity) {
        var args: [{{n}}]Box = undefined;

        {% for i in range(n) %}
        args[{{i}}] = arg{{i}};
        {% endfor %}

        const res = apply_closure_n(f, args[0..arity]);
        return apply_n(res.as_object(), args[arity..]);
    }
    {% endif %}
    
    // too little args
    @panic("should construct pap");
}
{% endfor %}

pub fn apply_closure_n(
    f: *Closure,
    args: []Box,
) Box {
    debug.assert(args.len > 0);

    switch (args.len) {
        {% for n in range(1, amount + 1) %}
            {{n}} => return apply_closure_{{n}}(
                f,
                {% for i in range(n) %}
                    args[{{i}}],
                {% endfor %}
            ),
        {% endfor %}
        else => @panic("unimplemented"),
    }
}

pub fn apply_n(
    f: Object,
    args: []Box,
) Box {
    switch (f.tag.kind()) {
        .Fun => return apply_closure_n(@ptrCast(f), args),
        .Pap => @panic("unimplemented"),
    }
}
